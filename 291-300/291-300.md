# 291 - 9061e44 支持使用`js`引入静态资源 + 打包`public`资源特殊处理

改动部分：

- `node/build/buildPluginAsset.ts resolveAsset`:  `public`开头的路径，将被打包进以`publicBase`参数的值为文件夹(详 **改动一**)
- `node/build/buildPluginCss.ts`：调用`resolveAsset`没有检测到资源，则不做任何处理，以免空资源被注入`bundle`中(`registerAssets`)
- `node/build/index.ts`：如果`/public`存在，则复制其资源（详 **改动三**）
- 新增`node/server/serverPluginAssets.ts`，静态资源转换为`export default "路径"`（详 **新增四**）

### 改动一

之前的资源统一打包的路径为：`slash(path.join(publicBase, assetsDir, resolvedFileName))`，即现在遇到`/^public(\/|\\)/`，去除`assetsDir`。

```typescript
// 获取相对路径
const pathFromRoot = path.relative(root, id)

// 检测是否public开头的文件路径
  if (/^public(\/|\\)/.test(pathFromRoot)) {
    // assets inside the public directory will be copied over verbatim
    // so all we need to do is just append the baseDir
    resolved = {
      content: null,
      fileName: null,
      // 是则资源会被放到publicBase传入的参数
      url: slash(path.join(publicBase, pathFromRoot))
    }
  }
```

### 改动三

`import icon from './public/icon.png'` -> **改动一**识别到public，则不把其路径改为`assets`，意义就是不要将`public`的资源打包进`assets`中。

```typescript
// vite 写入
if (write) {
    //skpi...
    
    // /public的资源都会被打包到/public中，全部均为复制
    const publicDir = path.resolve(root, 'public')
    if (await fs.pathExists(publicDir)) {
      await fs.copy(publicDir, path.resolve(outDir, 'public'))
    }
}
```

![1](1.png)

### 新增四

转换为`js`模块语言。

```typescript
import { Plugin } from '.'
import { isImportRequest, isStaticAsset } from '../utils'

export const assetPathPlugin: Plugin = ({ app }) => {
  app.use(async (ctx, next) => {
    if (isStaticAsset(ctx.path) && isImportRequest(ctx)) {
      ctx.type = 'js'
      ctx.body = `export default ${JSON.stringify(ctx.path)}`
      return
    }
    return next()
  })
}

```

> `import { Plugin } from '.'`，自动加载`/index.ts`



# 292 - 12a5d47 支持 --debug 标志 for windows

改动部分

`node/cli.ts`： 参数中传入`debug`，将设置`process.env.DEBUG = true`。

> 本次commit，添加了`crocess-env`，为了windows能够正确设置环境变量(程序变量？)



# 293 - 30c9bea 调整292

需要添加上`vite:`，否则不能触发（DEBUG包，已经有解析），如`require('debug')('vite:build:asset')`。

![2](2.png)



# 294 - e5cf447 `hmr`功能，支持`hot.dispose`

改动部分

- readme 因为新增了`hot.dispose`用例，需要给大家说一下dispose的使用（详 **改动一**）
- `node/server/serverPluginHmr.ts`
- `client/client.ts`，先进行`disposer()`，再发送请求获取新的js文件，获取完成后调用accept的回调方法，这样dispose触发就可以获取旧变量了，新的js文件将按照原来流程被调用callback
- `node/server/serverPluginHmr.ts`，AST语法树识别`dispose`（详 **改动四**）

### 改动一

使用`hot.dispose`，获取改动前的值。

```js
function setupSideEffect() {}
function cleanupSideEffect() {}

setupSideEffect()

if (__DEV__) {
  hot.dispose(cleanupSideEffect)
}
```

测试用例(`testHmrManual.js`)：

```typescript
import { hot } from '@hmr'

export const foo = 1

if (__DEV__) {
  hot.accept(({ foo }) => {
    console.log('foo is now: ', foo)
  })

  hot.dispose(() => {
    console.log('foo was: ', foo)
  })
}

// jest
      test('hmr (manual API)', async () => {
        await updateFile('testHmrManual.js', (content) =>
          content.replace('foo = 1', 'foo = 2')
        )
        await expectByPolling(() => logs[logs.length - 1], 'foo is now:  2')
        // there will be a "js module reloaded" message in between because
        // disposers are called before the new module is loaded.
        expect(logs[logs.length - 3]).toMatch('foo was:  1')
      })
```

### 改动四

