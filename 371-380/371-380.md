# 371 - 3e27277 chore git ignore explorations

`.gitignore`添加`explorations`文件夹，我们想提交PR，fork `vite`后，可以在创建`explorations`文件夹在里面乱用代码。

> 我这些调试的最方便了，不需要处理冲突，`sourcetree` merge UI线条也不会增多



# 372 - b2377bf `isImportRequest`兼容safari

我们可以在技术上使用更严格的检查，通过检查request 的`referer` 是不是compile-to-JS 源文件，但这不是在 Safari 中工作，因为 Safari 使用页面 URL 作为`referer`，即使对于 ES 模块imports。

```typescript
export const isImportRequest = (ctx: Context): boolean => {
  const dest = ctx.get('sec-fetch-dest')
  if (dest && dest !== 'script') {
    return false
  }
  return ctx.get('accept') === '*/*'
}
```

`sec-fetch-dest`：表示请求的目的地

`<link rel="stylesheet" href="/style.css">`显示`style`

`import('/style.css')`显示`script`



# 373 - 496b3fb wip(work in progress) service worker

改动部分：

- `src/node/server/serverPluginServiceWorker.ts`: （详 **新增一**）
- `src/sw/serviceWorker.ts`: （详 **新增二**）

> [service-worker深度教程](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle)

### serverPluginServiceWorker.ts 新增一

#### 洋葱模型执行顺序（更新-2）

```typescript
import { serveStaticPlugin } from './serverPluginServeStatic'
import { assetPathPlugin } from './serverPluginAssets'
import { cssPlugin } from './serverPluginCss'
import { jsonPlugin } from './serverPluginJson'
import { esbuildPlugin } from './serverPluginEsbuild'
import { vuePlugin } from './serverPluginVue'
import { moduleRewritePlugin } from './serverPluginModuleRewrite'
import { moduleResolvePlugin } from './serverPluginModuleResolve'
import { hmrPlugin, HMRWatcher } from './serverPluginHmr'
import { serviceWorkerPlugin } from './serverPluginServiceWorker.ts'

# node/server.ts
const internalPlugins: Plugin[] = [
  ...config.plugins,     // 洋葱模型的第一层  （自定）
  serviceWorkerPlugin,   // 洋葱模型的第二层  （里层）
  hmrPlugin,             // 洋葱模型的第三层  （里层）  
  moduleRewritePlugin,   // 洋葱模型的第四层  （外层） --
  moduleResolvePlugin,   // 洋葱模型的第五层  （里层）
  vuePlugin,             // 洋葱模型的第六层  （内层）
  esbuildPlugin,         // 洋葱模型的第七层  （外层） --
  jsonPlugin,            // 洋葱模型的第八层  （外层） --
  cssPlugin,             // 洋葱模型的第九层  （外层） --
  assetPathPlugin        // 洋葱模型的第十层  （里层） 
  ServerTransformPlugin, // 洋葱模型的第十一层（外层） -- 
  serveStaticPlugin      // 洋葱模型的第十二层（里层）
]
```

`vite`的`koa`插件，拦截`sw.js`发送`serviceWorker.js`文件（现在不分析todo要做的事情）

```typescript
import fs from 'fs'
import path from 'path'
import { ServerPlugin } from '.'

// 读取worker文件，__SERVER_TIMESTAMP__ 设置为vite服务开启时间
let swScript = fs
  .readFileSync(path.resolve(__dirname, '../serviceWorker.js'), 'utf-8')
  // inject server start time so the sw cache is invalidated
  .replace(/__SERVER_TIMESTAMP__ =.*/, `__SERVER_TIMESTAMP__ = ${Date.now()}`)

// TODO inject lockfile hash

// TODO resolve module entry directly during rewrite so that we don't need the
// redirect in module resolve plugin
// 尤大想在这里改写@module，这样我们就不用跳转了


export const serviceWorkerPlugin: ServerPlugin = ({
  app,
  watcher,
  resolver
}) => {
  if (process.env.DEBUG) {
    // 在debug模式下允许控制台输出信息
    swScript = swScript.replace(/\/\/ console.log/g, 'console.log')
  }

  // TODO watch lockfile hash

  // const bustSwCache = (file: string) => {
  //   // vue cache busting is handled in vue-specific client listeners
  //   // so we can invalidate each blocks separately
  //   if (!file.endsWith('.vue')) {
  //     watcher.send({
  //       type: 'sw-bust-cache',
  //       timestamp: Date.now(),
  //       path: resolver.fileToRequest(file)
  //     })
  //   }
  // }

  // watcher.on('change', bustSwCache)
  // watcher.on('unlink', bustSwCache)

  app.use(async (ctx, next) => {
    if (ctx.path === '/sw.js') {
      ctx.type = 'js'
      ctx.status = 200
      ctx.body = swScript
      return
    }
    return next()
  })
}
```

### 新增二

```typescript
// 这两个是由服务器动态注入的，以便我们在服务器重新启动或用户锁定文件更改时使缓存无效。
const __SERVER_TIMESTAMP__ = 1
const __LOCKFILE_HASH__ = 'a'

const CACHE_NAME = `vite-cache-${__SERVER_TIMESTAMP__ + __LOCKFILE_HASH__}`

const sw = (self as any) as ServiceWorkerGlobalScope

sw.addEventListener('install', () => {
  // 跳过等待上一次ws 开发模式下必用 否则需要关闭所有选项卡 & 刷新页面
  sw.skipWaiting()
})

sw.addEventListener('activate', (e) => {
  // 首次加载页面可以控制作用域内的请求（对时间敏感）
  sw.clients.claim()
    
  // 删除没有匹配到CACHE_NAME的缓存
  e.waitUntil(
    (async () => {
      const keys = await caches.keys()
      for (const key of keys) {
        if (key !== CACHE_NAME) {
          await caches.delete(key)
        }
      }
    })()
  )
})

sw.addEventListener('message', async (e) => {
  // 删除当前CACHE_NAME下的某缓存
  if (e.data.type === 'bust-cache') {
    const cache = await caches.open(CACHE_NAME)
    // console.log(`busted cache for ${e.data.path}`)
    cache.delete(e.data.path)
  }
})

const cacheableRequestRE = /^\/@modules\/|\.vue($|\?)|\.(t|j)sx?$|\.css$/
const hmrRequestRE = /(&|\?)t=\d+/

// 请求
sw.addEventListener('fetch', (e) => {
  const url = new URL(e.request.url)
  // @modules .vue .jsx .tsx .css使用缓存，但是拥有t参数的不使用缓存
  if (
    cacheableRequestRE.test(url.pathname) &&
    // no need to cache hmr update requests
    !url.search.match(hmrRequestRE)
  ) {
    e.respondWith(tryCache(e.request))
  }
})

async function tryCache(req: Request) {
  const cached = await caches.match(req)
  // 拥有缓存则返回缓存res
  if (cached) {
    // console.log(`serving ${req.url} from cache`)
    return cached
  } else {  
    // console.log(`fetching`, req)
    const res = await fetch(req)
    // console.log(`got res:`, res)
    // 无效请求 https://developer.mozilla.org/zh-CN/docs/Web/API/Response/type
    if (!res || res.status !== 200 || res.type !== 'basic') {
      // console.log(`not caching ${req.url}`)
      return res
    }
      
    // 缓存  
    // console.log(`caching ${req.url}`)
    const cache = await caches.open(CACHE_NAME)
    cache.put(req, res.clone())
    return res
  }
}
```