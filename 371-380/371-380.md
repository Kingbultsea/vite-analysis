# 371 - 3e27277 chore git ignore explorations

`.gitignore`添加`explorations`文件夹，我们想提交PR，fork `vite`后，可以在创建`explorations`文件夹在里面乱用代码。

> 我这些调试的最方便了，不需要处理冲突，`sourcetree` merge UI线条也不会增多



# 372 - b2377bf `isImportRequest`兼容safari

我们可以在技术上使用更严格的检查，通过检查request 的`referer` 是不是compile-to-JS 源文件，但这不是在 Safari 中工作，因为 Safari 使用页面 URL 作为`referer`，即使对于 ES 模块imports。

```typescript
export const isImportRequest = (ctx: Context): boolean => {
  const dest = ctx.get('sec-fetch-dest')
  if (dest && dest !== 'script') {
    return false
  }
  return ctx.get('accept') === '*/*'
}
```

`sec-fetch-dest`：表示请求的目的地

`<link rel="stylesheet" href="/style.css">`显示`style`

`import('/style.css')`显示`script`



# 373 - 496b3fb service worker

改动部分：

- `src/node/server/serverPluginServiceWorker.ts`: （详 **新增一**）
- `src/sw/serviceWorker.ts`: （详 **新增二**）
- `src/sw/tsconfig.json`: 

### 新增一

`vite`的`koa`插件，拦截`sw.js`发送`serviceWorker.js`文件（不包括todo要做的事情）

```typescript
import fs from 'fs'
import path from 'path'
import { ServerPlugin } from '.'

let swScript = fs
  .readFileSync(path.resolve(__dirname, '../serviceWorker.js'), 'utf-8')
  // inject server start time so the sw cache is invalidated
  .replace(/__SERVER_TIMESTAMP__ =.*/, `__SERVER_TIMESTAMP__ = ${Date.now()}`)

// TODO inject lockfile hash

// TODO resolve module entry directly during rewrite so that we don't need the
// redirect in module resolve plugin

export const serviceWorkerPlugin: ServerPlugin = ({
  app,
  watcher,
  resolver
}) => {
  if (process.env.DEBUG) {
    // enable console logs in debug mode
    swScript = swScript.replace(/\/\/ console.log/g, 'console.log')
  }

  // TODO watch lockfile hash

  // const bustSwCache = (file: string) => {
  //   // vue cache busting is handled in vue-specific client listeners
  //   // so we can invalidate each blocks separately
  //   if (!file.endsWith('.vue')) {
  //     watcher.send({
  //       type: 'sw-bust-cache',
  //       timestamp: Date.now(),
  //       path: resolver.fileToRequest(file)
  //     })
  //   }
  // }

  // watcher.on('change', bustSwCache)
  // watcher.on('unlink', bustSwCache)

  app.use(async (ctx, next) => {
    if (ctx.path === '/sw.js') {
      ctx.type = 'js'
      ctx.status = 200
      ctx.body = swScript
      return
    }
    return next()
  })
}
```

### 新增二

```typescript
// These two are injected by the server on the fly so that we invalidate the
// cache when the server restarts, or when the user lockfile has changed.
const __SERVER_TIMESTAMP__ = 1
const __LOCKFILE_HASH__ = 'a'

const CACHE_NAME = `vite-cache-${__SERVER_TIMESTAMP__ + __LOCKFILE_HASH__}`

const sw = (self as any) as ServiceWorkerGlobalScope

sw.addEventListener('install', () => {
  sw.skipWaiting()
})

sw.addEventListener('activate', (e) => {
  sw.clients.claim()
  // delete any non-matching caches
  e.waitUntil(
    (async () => {
      const keys = await caches.keys()
      for (const key of keys) {
        if (key !== CACHE_NAME) {
          await caches.delete(key)
        }
      }
    })()
  )
})

sw.addEventListener('message', async (e) => {
  if (e.data.type === 'bust-cache') {
    const cache = await caches.open(CACHE_NAME)
    // console.log(`busted cache for ${e.data.path}`)
    cache.delete(e.data.path)
  }
})

const cacheableRequestRE = /^\/@modules\/|\.vue($|\?)|\.(t|j)sx?$|\.css$/
const hmrRequestRE = /(&|\?)t=\d+/

sw.addEventListener('fetch', (e) => {
  const url = new URL(e.request.url)
  if (
    cacheableRequestRE.test(url.pathname) &&
    // no need to cache hmr update requests
    !url.search.match(hmrRequestRE)
  ) {
    e.respondWith(tryCache(e.request))
  }
})

async function tryCache(req: Request) {
  const cached = await caches.match(req)
  if (cached) {
    // console.log(`serving ${req.url} from cache`)
    return cached
  } else {
    // console.log(`fetching`, req)
    const res = await fetch(req)
    // console.log(`got res:`, res)
    if (!res || res.status !== 200 || res.type !== 'basic') {
      // console.log(`not caching ${req.url}`)
      return res
    }
    // console.log(`caching ${req.url}`)
    const cache = await caches.open(CACHE_NAME)
    cache.put(req, res.clone())
    return res
  }
}
```