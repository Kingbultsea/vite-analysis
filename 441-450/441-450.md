# 441 - 5769749 v0.15.3

release `vite` v0.15.3



# 442 - d1bdf5a `vite:resolve`插件，当alias不一样时才会调用resolve

msg: 修复`vite:resolve`与` node-resolve`插件公用的情况下出现的无限循环`resolve`问题。

**node-resolve源码分析：**

`vite:resolve`: 我处理不了这个id，交给其他人处理了。

` node-resolve`: 我找到了这个id的入口了，交给其他人去处理了，我会等待你们的结果，检测你们的`external`，再进行返回。

`vite:resolve`: 我处理不了这个id，交给其他人处理了。

....

重复下去... 一直没有人处理。

**改动后：**

`vite:resolve`: alias和原本id相同，其他插件按照原本流程处理吧。

` node-resolve`: 我找到了这个id的入口了，交给其他人去处理了，我会等待你们的结果，检测你们的`external`，再进行返回。

rollup表示没有人处理这个id，所以回归到` node-resolve`，返回id。

> rollup帮助我们避免了这个死循环，id本身并没有任何改变，所以我们没有察觉（然鹅速度非常慢）。

```typescript
export const createBuildResolvePlugin = (
  root: string,
  resolver: InternalResolver
): Plugin => {
  return {
    name: 'vite:resolve',
    async resolveId(id, importer) {
      const original = id
      id = resolver.alias(id) || id
        
      // ...
        
      // fallback to node-resolve becuase alias
      if (id !== original) {
        const resolved = this.resolve(id, importer, { skipSelf: true })
        return resolved || { id }
      }
    },
    load(id: string) {
    }
  }
}
```



# 443 - 84cff52 确保vue被安装

`node/utils/resolveVue.ts`: `isLocal`的判断仅仅是检测依赖上有没有vue包，并不是检测`node_modules`能否寻找到vue包，现在为了严谨性，调用`resolveFrom`看看是否能引入该包，否则`isLocal`为`false`



# 444 - bdc7e70 添加`shouldPreload`在可配置选项中，可预加载非主`chunk`资源 [#144](https://github.com/vitejs/vite/pull/144)

构建完毕后，调用renderIndex -> (非主chunk) ->  shouldPreload(chunk) 验证通过后，`<link red="modulepreload" href="${filename}" />`植入标签到html。

```typescript
# node/config.ts
export interface BuildConfig extends SharedConfig {
  // ...
  /**
   * 是否把link rel=modulepreload注入到index.html中
   */
  shouldPreload?: (chunk: OutputChunk) => boolean
}

# build/buildPluginHtml.ts
const injectPreload = (html: string, filename: string) => {
  filename = isExternalUrl(filename)
    ? filename
    : `${publicBasePath}${path.posix.join(assetsDir, filename)}`
  const tag = `<link rel="modulepreload" href="${filename}" />`
  if (/<\/head>/.test(html)) {
    return html.replace(/<\/head>/, `${tag}\n</head>`)
  } else {
    return tag + '\n' + html
  }
}

const renderIndex = (
    bundleOutput: RollupOutput['output'],
    cssFileName: string
  ) => {
    // inject css link
    processedHtml = injectCSS(processedHtml, cssFileName)
    // inject js entry chunks
    for (const chunk of bundleOutput) {
      if (chunk.type === 'chunk') {
        if (chunk.isEntry) {
          processedHtml = injectScript(processedHtml, chunk.fileName)
        } else if (shouldPreload && shouldPreload(chunk)) {
          processedHtml = injectPreload(processedHtml, chunk.fileName)
        }
      }
    }
    return processedHtml
  }
```

**sventschui**: 此PR添加了一个名为`shouldlpreload`的可选配置选项，该选项接收`rollup OutputChunk`作为function的参数，并返回一个布尔值，指示是否向`index.html`添加`<link rel=“modulerepload”href=“…”/>`。

欢迎反馈。也许更通用的解决方案是提供添加html处理插件的功能。

**sventschui**: Fixed typo & rebased.希望现在一切都好

**yyx**: 我想知道是否有方法可以自动执行此操作-例如，如果入口块需要一个公共块，那么它应该自动预加载。我想我也在试图弄清楚什么时候真的需要这个方法，或者我们应该提供一个更通用的HTML处理选项。目前Vite只支持单个入口（除非通过`rollupInputOptions`显式配置），因此只有在使用动`dynamic imports`分离代码时，才会出现单独的块，否则它们将始终位于主块中。您是否有更具体的案例计划使用此功能？

> 尤大目前意思是vite不会代码分割，除非自己通过rollup输出代码，所以输出的只会输出一个主chunk，sventschui提出的shouldPreload(chunk) ，将会是一个主`chunk` + `dynamicimported chunk`。

**sventschui**: 用例是预加载验证后所需的块 (i.e. [https://prelease.netlify.app](https://prelease.netlify.app/) 提供了一个 "Authenticate with GitHub"按钮作为未验证时的唯一入口点，认证后会加载`@urql/preact` + `graphql`，大约35KB)。

> **yyx**: 我想知道是否有方法可以自动执行此操作-例如，如果入口块需要一个公共块，那么它应该自动预加载。

这是个好主意。但有一件事是，这仅适用于一个级别（即`main chunk` -> `common chunk`）。在我的情况下，有两个级别（即`main chunk` -> `dynamicimported chunk` -> `common chunk`）我希望两者都被预加载。

> Chrome在50版中添加了对<link rel =“ preload”>的支持，这是一种在浏览器需要资源之前以声明方式提前请求资源的方法。
>
> isEntry chunk就是主chunk。
>
> common chunk公共模块。
>
> dynamicimported chunk异步块。
>
> 后续会详细讲解，因为我能看出尤大蠢蠢欲动。
>
> 支持`publicBasePath`



# 445 - 00f4a83 强制esbuild服务输出ES2019 [#155](https://github.com/vitejs/vite/pull/155)

**Dykam**: Rollup 似乎不支持可选链（foo?.bar）。通过将 esbuild 目标降低到 ES2019 来解决此问题。
这纯粹是一个建议，我知道可能会有意想不到的后果。我也可以想到你可能只想对rollup执行此操作。

![1](1.png)

rollup不支持可选链（Es2020）。

> The reason Acorn hasn't landed optional chaining is due to the estree block over how to implement the Node structure. RollupJS doesn't publicly expose the Node interface so I don't believe Rollup as a project should be slowed down by the lack of consensus building work being done here, if it doesn't actually affect Rollup.
>
> Acorn 没有上这个功能是因为estree相关规范还没有定下来。

esbuild是用来转ts，(在renderChunk的时候压缩代码，但是传递给esbuild的只有minify字段)，把目标输出为es2019就可以了。

[rollup-3582](https://github.com/rollup/rollup/pull/3582): 支持可选链。

[#525](https://github.com/vitejs/vite/pull/525/files)升级后，将支持可选链。

> 这个修复也是有缺陷的，不能在js里面用。
>
> 同时发现esbuild不支持转换async，https://esbuild.github.io/content-types/#es5，不支持转换es5，那就得交给rollup了。

