# 551 - db8b6b2 #235 支持自定义`NODE_ENV`

改动部分：

- `src/node/cli.ts`：新增`--mode | -m`，默认serve模式下`development`，build模式下`production`
- `src/node/config.ts`：新增`loadEnv`方法，加载`env.XXXX`，默认优先加载`.env`文件（详 **改动二**）

> 之前支持的仅仅是`.env`，这次PR主要是可以通过命令行配置mode，来加载`.env.${mode}`文件来动态配置

### 改动二

检测顺序：`.env` -> `.env.local` -> `.env.${mode}` -> `.env.${mode}.local`

```typescript
// load environment variables
    const env = loadEnv(mode, cwd)
    debug(`env: %O`, env)
    config.env = env

function loadEnv(mode: string, cwd: string): Record<string, string> {
  debug(`env mode: ${mode}`)
  const { resolve } = path
  
  // 检测的现后顺序
  const envFiles = [
    /** default file */ resolve(cwd, '.env'),
    /** local file */ resolve(cwd, `.env.local`),
    /** mode file */ resolve(cwd, `.env.${mode}`),
    /** mode local file */ resolve(cwd, `.env.${mode}.local`)
  ]

  const env: Record<string, string> = {}
  for (const file of envFiles) {
    if (fs.existsSync(file) && fs.statSync(file).isFile()) {
      const result = dotenv.config({
        debug: !!process.env.DEBUG,
        path: file
      })
      if (result.error) {
        throw result.error
      }
      Object.assign(env, result.parsed)
    }
  }

  return env
}
```



# 552 - cf5de5b #243 重构 vue hmr，使用hot.accept来替换

**underfin**: 我这样做是因为我认为让内置Vue进程的逻辑使用插件来实现是很有用的。我认为Vue模块的HMR应该由HMR API实现，而不是使用内部逻辑实现。

改动部分：

- `src/client/client.ts`：去除`vue-reload`、`vue-rerender`和`vue-style-update`事件，不再调用`updateStyle`，只做一个api输出。
- `src/node/server/serverPlginCss.ts`：转换import类型的css所植入的js代码被封装为`codegenCss`方法中。（详 **改动二**）
- `src/node/server/serverPluginHmr.ts`：添加`vueReload`（实际也是`js-update`）方法，`<script>`、`<style>`（`module`和`scope`）都会触发`vueReload`，`<style>`内容的不同会触发`style-update`（详 **改动三**）

### 改动二

科普一下如果单纯引入css会出现什么结果，统一转换为js代码，出现BUG，并没有正确引入：

![1](1.png)

### 改动三 `handleVueReload`

所有事件均变为触发`js-update`。

```typescript
async function handleVueReload(
  file: string,
  timestamp: number = Date.now(),
  content?: string
) {
  const publicPath = resolver.fileToRequest(file)
  const cacheEntry = vueCache.get(file)

  debugHmr(`busting Vue cache for ${file}`)
  vueCache.del(file)

  const descriptor = await parseSFC(root, file, content)
  if (!descriptor) {
    // read failed
    return
  }

  const prevDescriptor = cacheEntry && cacheEntry.descriptor
  if (!prevDescriptor) {
    // the file has never been accessed yet
    debugHmr(`no existing descriptor found for ${file}`)
    return
  }

  // check which part of the file changed
  let needRerender = false

  const vueReload = () => {
    send({
      type: 'js-update',
      path: publicPath,
      changeSrcPath: publicPath,
      timestamp
    })
    console.log(
      chalk.green(`[vite:hmr] `) +
        `${path.relative(root, file)} updated. (reload)`
    )
  }

  if (!isEqual(descriptor.script, prevDescriptor.script)) {
    vueReload()
    return
  }

  if (!isEqual(descriptor.template, prevDescriptor.template)) {
    needRerender = true
  }

  let didUpdateStyle = false
  const styleId = hash_sum(publicPath)
  const prevStyles = prevDescriptor.styles || []
  const nextStyles = descriptor.styles || []

  // css modules update causes a reload because the $style object is changed
  // and it may be used in JS. It also needs to trigger a vue-style-update
  // event so the client busts the sw cache.
  if (
    prevStyles.some((s) => s.module != null) ||
    nextStyles.some((s) => s.module != null)
  ) {
    vueReload()
    return
  }

  if (prevStyles.some((s) => s.scoped) !== nextStyles.some((s) => s.scoped)) {
    needRerender = true
  }

  // only need to update styles if not reloading, since reload forces
  // style updates as well.
  nextStyles.forEach((_, i) => {
    if (!prevStyles[i] || !isEqual(prevStyles[i], nextStyles[i])) {
      didUpdateStyle = true
      send({
        type: 'style-update',
        path: `${publicPath}?type=style&index=${i}`,
        timestamp
      })
    }
  })

  // stale styles always need to be removed
  prevStyles.slice(nextStyles.length).forEach((_, i) => {
    didUpdateStyle = true
    send({
      type: 'style-remove',
      path: publicPath,
      id: `${styleId}-${i + nextStyles.length}`,
      timestamp
    })
  })

  if (needRerender) {
    send({
      type: 'js-update',
      path: publicPath,
      changeSrcPath: `${publicPath}?type=template`,
      timestamp
    })
  }

  if (needRerender || didUpdateStyle) {
    let updateType = needRerender ? `template` : ``
    if (didUpdateStyle) {
      updateType += ` & style`
    }
    console.log(
      chalk.green(`[vite:hmr] `) +
        `${path.relative(root, file)} updated. (${updateType})`
    )
  }
}
```

